// namespace DZ9.Ответы;


/*
1. Инкапсуляция это когда мы растусовываем переменные/классы/объекты под своими модификаторами доступы, чтобы нельзя было 
получить легко доступ к прайвт классам. Это делает объекты более надежными и уменьшает вероятность ошибок, связанных 
с изменением внутренней реализации объекта.

2. Да, если я верно понимаю полимофизм, то мы можем делать это через создания экземпляра класса

3. Гугл сказал - Ошибка преобразования типов при upcast возможна только в том случае, если производный класс не 
является наследником базового класса или является наследником другого класса, который не связан с базовым классом.
Например, если у нас есть класс Car и производный от него класс SportsCar, то мы можем безопасно выполнить upcast объекта SportsCar к типу Car, так как SportsCar является наследником Car. Однако, если у нас есть другой производный класс Truck, который также является наследником класса Vehicle, но не имеет отношения к классу Car, то при попытке выполнить upcast объекта класса Truck к типу Car, возникнет ошибка:

Truck myTruck = new Truck();
Car myCar = (Car)myTruck;  Ошибка: нельзя выполнить upcast от Truck к Car

--
Также может возникнуть ошибка, если мы попытаемся выполнить upcast объекта, который был создан с использованием ключевого слова new для переопределения метода базового класса. В этом случае мы можем получить неожиданный результат при вызове метода базового класса:

csharp
Copy code
class Car {
    public virtual void Drive() {
        Console.WriteLine("Driving a car");
    }
}

class SportsCar : Car {
    public new void Drive() {
        Console.WriteLine("Driving a sports car");
    }
}

SportsCar mySportsCar = new SportsCar();
Car myCar = (Car)mySportsCar;
myCar.Drive(); // Выводит "Driving a car", так как используется метод базового класса

Поэтому при использовании upcast необходимо быть внимательными и убедиться, что производный класс является наследником базового класса,
 и что не происходит переопределение методов базового класса с помощью ключевого слова new.
*/